<HTML><HEADER>
<!-- manual page source format generated by RosettaMan, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->
<TITLE>man page(1) manual page</TITLE>
</HEADER><BODY>
<A HREF="#toc">Table of Contents</A><P>
_________________________________________________________________<P>
<H2><A NAME="sect0" HREF="#toc0"><B>NAME</B></A></H2>
bgexec - Run Unix commands in the background while handling Tk events.<P>
<H2><A NAME="sect1" HREF="#toc1"><B>SYNOPSIS</B></A></H2>
<B>bgexec</B> <I>varName</I> ?<I>option</I> <I>value</I>?... <I>command</I> ?<I>arg</I>?... _________________________________________________________________<P>
<H2><A NAME="sect2" HREF="#toc2"><B>DESCRIPTION</B></A></H2>
The <B>bgexec</B> command executes Unix commands in the background, allowing Tk to handle events. A global Tcl variable <I>varName</I> is set when the command has completed.<P>
<H2><A NAME="sect3" HREF="#toc3"><B>INTRODUCTION</B></A></H2>
Tcl's <B>exec</B> command is very useful for gathering information from the Unix system. It runs a Unix command and returns the output of the command as its result. This works well for Tcl-only applications. But in Tk applications, a problem occurs when a Unix command takes time to process. For example, let's say we want the get the disk usage of a directory. We'll use the Unix command <B>du</B> to get the summary.<P>
<B>set</B> <B>out</B> <B>[exec</B> <B>du</B> <B>-s</B> <B>$dir]</B><BR>
 <B>puts</B> <B>&quot;Disk</B> <B>usage</B> <B>for</B> <B>$dir</B> <B>is</B> <B>$out"</B><P>
While <B>du</B> is running, scrollbars won't respond. None of the Tk widgets will be redrawn properly. The <B>send</B> command won't work. And the worst part is that the application appears hung up or dead. The problem is that while the application is waiting for <I>du</I> to finish, Tk is not handling X events.<P>
The <B>bgexec</B> command performs the same functions as <B>exec</B>, but also allows Tk to handle events. You can execute a long-running Unix command and the Tk widgets will behave normally. When the command finishes, its output and the exit status are written to Tcl variables. This makes it easy to monitor and save the output of a command.<P>
<H2><A NAME="sect4" HREF="#toc4"><B>EXAMPLE</B></A></H2>
This is the disk usage example again, this time using <B>bgexec</B>. The Unix command syntax is exactly the same as the previous example, when we used <B>exec</B>.<P>
<B>global</B> <B>myStatus</B> <B>myOutput</B><BR>
 <B>bgexec</B> <B>myStatus</B> <B>-output</B> <B>myOutput</B> <B>du</B> <B>-s</B> <B>$dir</B> <B>puts</B> <B>&quot;Disk</B> <B>usage</B> <B>for</B> <B>$dir</B> <B>is</B> <B>$myOutput"</B><P>
Two global variables, <B>myStatus</B> and <B>myOutput</B>, will be set by <B>bgexec</B> when the <B>du</B> command has completed. <B>MyStatus</B> will contain the command's exit status. <B>MyOutput</B>, specified by the <B>-output</B> option, will store the output of the command.<P>
You can also terminate the command by setting the variable <B>myStatus</B>. If <B>myStatus</B> is set before <B>du</B> has completed, the process is killed by sending a configurable Unix signal (by default it's SIGKILL). It makes no difference what <B>myStatus</B> is set to.<P>
<B>set</B> <B>myStatus</B> <B>{}</B><P>
There are other <B>bgexec</B> options to collect different types of information.<P>
<B>global</B> <B>myStatus</B> <B>myOutput</B> <B>myErrs</B><BR>
 <B>bgexec</B> <B>myStatus</B> <B>-output</B> <B>myOutput</B> <B>-error</B> <B>myErrs</B> <B>du</B> <B>-s</B> <B>$dir</B><P>
The <B>-error</B> option is similar to <B>-output</B>. It sets a global variable when the command completes. The variable will contain any data written to stderr by the command.<P>
The <B>-output</B> and <B>-error</B> variables are written to only after the command completes. If the command takes a long time, you may want to receive its partial output. You can gather data as it becomes available using the <B>-update</B> option. It sets a global variable as new data is output.<P>
<B>global</B> <B>myStatus</B> <B>myInfo</B><BR>
 <B>trace</B> <B>variable</B> <B>myInfo</B> <B>w</B> <B>TraceInfo</B> <B>bgexec</B> <B>myStatus</B> <B>-update</B> <B>myInfo</B> <B>du</B> <B>-s</B> <B>$dir</B><P>
When new data becomes available, the variable <B>myInfo</B> is updated. A Tcl variable trace is used to handle the updates when they occur. Whenever <B>myInfo</B> is updated, the proc <B>TraceInfo</B> will be called.<P>
Like <B>exec</B>, <B>bgexec</B> returns an error if the exit code of the Unix command is not zero. If you think you may get a nonzero exit code, you might want to invoke <B>bgexec</B> from within a <B>catch</B>.<P>
<B>catch</B> <B>{</B> <B>bgexec</B> <B>myStatus</B> <B>-output</B> <B>myOutput</B> <B>du</B> <B>-s</B> <B>$dir</B> <B>}</B><P>
By default, <B>bgexec</B> will wait for the command to finish. But you can detach the command by adding an ampersand (&amp;) to the end of the command line.<P>
<B>global</B> <B>myStatus</B> <B>myOutput</B><BR>
 <B>bgexec</B> <B>myStatus</B> <B>-output</B> <B>myOutput</B> <B>du</B> <B>-s</B> <B>$dir</B> <B>&amp;</B><P>
<B>Bgexec</B> will return immediately and its result will be a list of the spawned process ids. If at some point, you need to wait for the command to finish, you can use <B>tkwait</B>. When the command finishes, the variable <B>myStatus</B> will be written to, breaking the <B>tkwait</B> loop.<P>
<B>global</B> <B>myStatus</B> <B>myOutput</B><BR>
 <B>bgexec</B> <B>myStatus</B> <B>-output</B> <B>myOutput</B> <B>du</B> <B>-s</B> <B>$dir</B> <B>&amp;</B> <B>...</B><BR>
 <B>tkwait</B> <B>variable</B> <B>myStatus</B><P>
<H2><A NAME="sect5" HREF="#toc5"><B>SYNTAX</B></A></H2>
The <B>bgexec</B> command takes the following form:<P>
<B>bgexec</B> <I>varName</I> ?<I>option</I> <I>value</I>?... <I>command</I> ?<I>arg</I>?...<P>
<I>VarName</I> is the name of a global variable which is set when the designated Unix command has finished executing. The exit status of the command will be stored in <I>varName</I>. The exit status is a list of a status token, the process-id of the command, the exit code, and a status message. You can also prematurely terminate the command by setting <I>varName</I>. The command will be sent a signal to terminate it (by default the signal is a SIGKILL; see the <B>-killsignal</B> option).<P>
<I>Command</I> is the name of the Unix command to be executed and <I>args</I> are any extra arguments for <I>command</I>. <I>Command</I> and <I>args</I> may be in any form accepted by <B>exec</B>. (See the <B>exec</B> manual for further information.) If the last argument is an ampersand (&amp;), the command will be run detached, and <B>bgexec</B> will return immediately. <I>VarName</I> will still be set with the return status when <I>command</I> completes.<P>
<H2><A NAME="sect6" HREF="#toc6"><B>OPTIONS</B></A></H2>
<I>Option</I> is the switch name, always beginning with a dash (-). <I>Value</I> is the value of the option. Option-value pairs are terminated either by the Unix command name, or double dashes (--). The following options are available for <B>bgexec</B>:<P>
<dl>
<dt><B>-error</B> <I>varName</I><dd> Specifies that a global variable <I>varName</I> is to be set with the contents of stderr after the command has completed.<P>
</dd>
</dl>
<dl>
<dt><B>-keepnewline</B> <I>boolean</I><dd> Specifies that a trailing newline should be retained in the output. If <I>boolean</I> is true, the trailing newline is truncated from the output of the <B>-update</B> and <B>-output</B> variables. The default value is <B>true</B>.<P>
</dd>
</dl>
<dl>
<dt><B>-killsignal</B> <I>signal</I><dd> Specifies the signal to be sent to the Unix command when terminating. <I>Signal</I> can either be a number (typically 1-32) or a mnemonic (e.g. SIGINT). If <I>signal</I> is the empty string, then no signal is sent. The default signal is <B>9</B> (SIGKILL).<P>
</dd>
</dl>
<dl>
<dt><B>-output</B> <I>varName</I><dd> Specifies that a global variable <I>varName</I> is to be set with the output of the command, after the commmand has completed. If this option is not set, no output will be accumulated.<P>
</dd>
</dl>
<dl>
<dt><B>-update</B> <I>varName</I><dd> Specifies that a global variable <I>varName</I> is to be updated when data is written to stdout of the command. Unlike the <B>-output</B> option, <I>varName</I> is updated as soon as new data becomes available.<P>
</dd>
</dl>
<dl>
<dt><B>--</B> <dd>This marks the end of the options. The following argument will be considered the name of a Unix command even if it starts with a dash (<B>-</B>).<P>
</dd>
</dl>
<H2><A NAME="sect7" HREF="#toc7"><B>PREEMPTION</B></A></H2>
Because Tk events are handled while a Unix command is running, it's possible for an application to preempt itself with further user-interactions. Let's say your application has a button, that when pressed runs the disk usage example. While the <B>du</B> command is already running, the user may press the button again. The second <B>bgexec</B> command will preempt the first. This means that the first command can not finish until the second command has completed.<P>
Care must be taken to prevent an application from preempting itself, by blocking further user-interactions (such as button clicks). The BLT <B>busy</B> command is very useful in these situations, temporarily preventing user interaction. See the <B>busy</B> manual for details.<P>
<H2><A NAME="sect8" HREF="#toc8"><B>DIFFERENCES</B> <B>WITH</B> <B>FILEEVENT</B></A></H2>
Some of the functionality of <B>bgexec</B> is now be provided in Tk 4.0 with the <B>fileevent</B> command. The steps for running a command in the background are:<P>
Execute the Unix command with the <B>open</B> command (using the &quot;|&quot; syntax) and save the file handle.<P>
<B>global</B> <B>fileId</B><BR>
 <B>set</B> <B>fileId</B> <B>[open</B> <B>&quot;|du</B> <B>-s</B> <B>$dir&quot;</B> <B>r]</B><P>
Next register a Tcl code snippet with <B>fileevent</B> to be run whenever output is available on the file handle. The code snippet will read from the file handle and save the output in a variable.<P>
<B>fileevent</B> <B>fileId</B> <B>readable</B> <B>{</B><BR>
 <B>if</B> <B>{</B> <B>[gets</B> <B>$fileId</B> <B>line]</B> <B>&lt;</B> <B>0</B> <B>}</B> <B>{</B> <B>close</B> <B>$fileId</B><BR>
 <B>set</B> <B>output</B> <B>$temp</B><BR>
 <B>unset</B> <B>fileId</B> <B>temp</B><P>
<B>}</B> <B>else</B> <B>{</B><BR>
 <B>append</B> <B>temp</B> <B>$line</B><BR>
 <B>}</B><BR>
 <B>}</B><P>
While this works with the above example, but there are some important differences.<P>
The biggest advantage of <B>bgexec</B> is that it requires no additional Tcl code to run a Unix command. It's simpler, and therefore there's less chance of errors being introduced.<P>
<B>Bgexec</B> also handles things that <B>fileevent</B> can not. For example, you can't get back the exit status of the command. In the code above, we're assuming that the command has completed once stdout is closed. The problem is that some commands, like <B>compress</B>, reopen stdout, which fool <B>fileevent</B>. We're also assuming that the Unix command will write its output line-by-line. Running another command, your application may block in the <B>gets</B> command, reading a partial line. Conversely, <B>bgexec</B> handles non-blocking I/O tranparently for you. Finally, since data collection is handled in C code, <B>bgexec</B> is faster, getting you back to the Tk event loop more quickly.<P>
<H2><A NAME="sect9" HREF="#toc9"><B>SEE</B> <B>ALSO</B></A></H2>
busy, exec, tkwait<P>
<H2><A NAME="sect10" HREF="#toc10"><B>KEYWORDS</B></A></H2>
exec, background, busy<P>
<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTRODUCTION</A></LI>
<LI><A NAME="toc4" HREF="#sect4">EXAMPLE</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SYNTAX</A></LI>
<LI><A NAME="toc6" HREF="#sect6">OPTIONS</A></LI>
<LI><A NAME="toc7" HREF="#sect7">PREEMPTION</A></LI>
<LI><A NAME="toc8" HREF="#sect8">DIFFERENCES WITH FILEEVENT</A></LI>
<LI><A NAME="toc9" HREF="#sect9">SEE ALSO</A></LI>
<LI><A NAME="toc10" HREF="#sect10">KEYWORDS</A></LI>
</UL>
</BODY></HTML>
