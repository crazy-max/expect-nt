<HTML><HEADER>
<!-- manual page source format generated by RosettaMan, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->
<TITLE>man page(1) manual page</TITLE>
</HEADER><BODY>
<A HREF="#toc">Table of Contents</A><P>
_________________________________________________________________<P>
<H2><A NAME="sect0" HREF="#toc0"><B>NAME</B></A></H2>
vector - Vector data type for Tcl<P>
<H2><A NAME="sect1" HREF="#toc1"><B>SYNOPSIS</B></A></H2>
<B>vector</B> <I>vecName</I><BR>
 _________________________________________________________________<P>
<H2><A NAME="sect2" HREF="#toc2"><B>DESCRIPTION</B></A></H2>
The <B>vector</B> command creates a vector of floating point values. The vector's components can be manipulated in three ways: through a Tcl array variable, a Tcl command, or the C API.<P>
<H2><A NAME="sect3" HREF="#toc3"><B>INTRODUCTION</B></A></H2>
A vector is simply an ordered set of numeric values. The components of a vector are floating point numbers which are indexed by counting numbers.<P>
Vectors are common data structures for many applications. For example, a graph may use two vectors to represent the x and y coordinates of the data plotted. By using vectors, you separate data analysis from the graph widget. This makes it easier, for example, to add data transformations, such as splines. It's possible to plot the same data to in multiple graphs, where each graph presents a different view or scale of the data.<P>
You could try to use Tcl's associative arrays as vectors. Tcl arrays are easy to use. You can access individual elements randomly by specifying the index, or the set the entire array by providing a list of index and value pairs for each element. The disadvantages of associative arrays as vectors lie in the fact they are implemented as hash tables.<P>
<dl>
<dt>· There's no implied ordering to the associative arrays.<dd> If you used vectors for plotting, you would want to insure the second component comes after the first, an so on. This isn't possible since arrays are actually hash tables. For example, you can't get a range of values between two indices. Nor can you sort an array.<P>
</dd>
</dl>
<dl>
<dt>· Arrays consume lots of memory when the number of ele<dd>ments becomes large (tens of thousands). This is because each element's index and value are stored as strings in the hash table.<P>
</dd>
</dl>
<dl>
<dt>· The C programming interface is unwieldy. Normally with<dd> vectors, you would like to view the Tcl array as you do a C array, as an array of floats or doubles. But with hash tables, you must convert both the index and value to and from decimal strings, just to access an element in the array. This makes it cumbersome to perform operations on the array as a whole.<P>
</dd>
</dl>
The <B>vector</B> command tries to overcome these disadvantages while still retaining the ease of use of Tcl arrays. The <B>vector</B> command creates both a new Tcl command and associate array which are linked to the vector components. You can randomly access vector components though the elements of array. Not have all indices are generated for the array, so printing the array (using the <B>parray</B> procedure) does not print out all the component values. You can use the Tcl command to access the array as a whole. You can copy, append, or sort vector using its command. If you need greater performance, or customized behavior, you can write your own C code to manage vectors.<P>
<H2><A NAME="sect4" HREF="#toc4"><B>EXAMPLE</B></A></H2>
You create vectors using the <B>vector</B> command.<P>
<B>#</B> <B>Create</B> <B>a</B> <B>new</B> <B>vector.</B><BR>
 <B>vector</B> <A HREF="http://localhost:6711/man?y?50">y(50)</A><P>
This creates a new vector named <B>y</B>. It has fifty components, by default, initialized to <B>0.0</B>. In addition, both a Tcl command and array variable, both named <B>y</B>, are created. You can use either the command or variable to query or modify components of the vector.<P>
<B>#</B> <B>Set</B> <B>the</B> <B>first</B> <B>value.</B><BR>
 <B>set</B> <B>y(0)</B> <B>9.25</B><BR>
 <B>puts</B> <B>&quot;y</B> <B>has</B> <B>[y</B> <B>length]</B> <B>components"</B><P>
The array <B>y</B> can be used to read or set individual components of the vector. Vector components are indexed from zero. The array index must be a number less than the number of components. For example, it's an error if you try to set the 51st element of <B>y</B>.<P>
<B>#</B> <B>This</B> <B>is</B> <B>an</B> <B>error.</B> <B>The</B> <B>vector</B> <B>only</B> <B>has</B> <B>50</B> <B>components.</B> <B>set</B> <A HREF="http://localhost:6711/man?y?50">y(50)</A> 0.02<P>
You can also specify a range of indices using a colon (:) to separate the first and last indices of the range.<P>
<B>#</B> <B>Set</B> <B>the</B> <B>first</B> <B>six</B> <B>components</B> <B>of</B> <B>y</B> <B>set</B> <B>y(0:5)</B> <B>25.2</B><P>
If you don't include an index, then it will default to the first and/or last component of the vector.<P>
<B>#</B> <B>Print</B> <B>out</B> <B>all</B> <B>the</B> <B>components</B> <B>of</B> <B>y</B> <B>puts</B> <B>&quot;y</B> <B>=</B> <B>$y(:)"</B><P>
There are special non-numeric indices. The index <B>end</B>, specifies the last component of the vector. It's an error to use this index if the vector is empty (length is zero). The index <B>++end</B> can be used to extend the vector by one component and initialize it to a specific value. You can't read from the array using this index, though.<P>
<B>#</B> <B>Extend</B> <B>the</B> <B>vector</B> <B>by</B> <B>one</B> <B>component.</B> <B>set</B> <B>y(++end)</B> <B>0.02</B><P>
The other special indices are <B>min</B> and <B>max</B>. They return the current smallest and largest components of the vector.<P>
<B>#</B> <B>Print</B> <B>the</B> <B>bounds</B> <B>of</B> <B>the</B> <B>vector</B> <B>puts</B> <B>&quot;min=$y(min)</B> <B>max=$y(max)</B><P>
To delete components from a vector, simply unset the corresponding array element. In the following example, the first component of <B>y</B> is deleted. All the remaining components of <B>y</B> will be moved down by one index as the length of the vector is reduced by one.<P>
<B>#</B> <B>Delete</B> <B>the</B> <B>first</B> <B>component</B><BR>
 <B>unset</B> <B>y(0)</B><BR>
 <B>puts</B> <B>&quot;new</B> <B>first</B> <B>element</B> <B>is</B> <B>$y(0)"</B><P>
The vector's Tcl command can also be used to query or set the vector.<P>
<B>#</B> <B>Create</B> <B>and</B> <B>set</B> <B>the</B> <B>components</B> <B>of</B> <B>a</B> <B>new</B> <B>vector</B> <B>vector</B> <B>x</B><BR>
 <B>x</B> <B>set</B> <B>{</B> <B>0.02</B> <B>0.04</B> <B>0.06</B> <B>0.08</B> <B>0.10</B> <B>0.12</B> <B>0.14</B> <B>0.16</B> <B>0.18</B> <B>0.20</B> <B>}</B><P>
Here we've created a vector <B>x</B> without a initial length specification. In this case, the length is zero. The <B>set</B> operation resets the vector, extending it and setting values for each new component.<P>
There are several operations for vectors. The <B>range</B> operation lists the components of a vector between two indices.<P>
<B>#</B> <B>List</B> <B>the</B> <B>components</B><BR>
 <B>puts</B> <B>&quot;x</B> <B>=</B> <B>[x</B> <B>range</B> <B>0</B> <B>end]"</B><P>
You can search for a particular value using the <B>search</B> operation. It returns a list of indices of the components with the same value. If no component has the same value, it returns <B>&quot;"</B>.<P>
<B>#</B> <B>Find</B> <B>the</B> <B>index</B> <B>of</B> <B>the</B> <B>biggest</B> <B>component</B> <B>set</B> <B>indices</B> <B>[x</B> <B>search</B> <B>$x(max)]</B><P>
Other operations copy, append, or sort vectors. You can append vectors or new values onto an existing vector with the <B>append</B> operation.<P>
<B>#</B> <B>Append</B> <B>assorted</B> <B>vectors</B> <B>and</B> <B>values</B> <B>to</B> <B>x</B> <B>x</B> <B>append</B> <B>x2</B> <B>x3</B> <B>{</B> <B>2.3</B> <B>4.5</B> <B>}</B> <B>x4</B><P>
The <B>sort</B> operation sorts the vector. If any additional vectors are specified, they are rearranged in the same order as the vector. For example, you could use it to sort data points represented by x and y vectors.<P>
<B>#</B> <B>Sort</B> <B>the</B> <B>data</B> <B>points</B><BR>
 <B>x</B> <B>sort</B> <B>y</B><P>
The vector <B>x</B> is sorted while the components of <B>y</B> are rearranged so that the original x,y coordinate pairs are retained.<P>
There also are operations to perform arithmetic. They second operand can be either another vector or a scalar value.<P>
<B>#</B> <B>Add</B> <B>the</B> <B>two</B> <B>vectors</B> <B>and</B> <B>a</B> <B>scalar</B> <B>puts</B> <B>&quot;x+y=[x</B> <B>+</B> <B>y]"</B><BR>
 <B>puts</B> <B>&quot;x*2=[x</B> <B>*</B> <B>2]"</B><P>
When a vector is modified, resized, or deleted, it may trigger call-backs to notify the clients of the vector. For example, when a vector used in the <B>graph</B> widget is updated, the vector automatically notifies the widget that it has changed. The graph can then redrawn itself at the next idle point. By default, the notification occurs when Tk is next idle. This way you can modify the vector many times without incurring the penalty of the graph redrawing itself for each change. You can change this behavior using the <B>notify</B> operation.<P>
<B>#</B> <B>Make</B> <B>vector</B> <B>x</B> <B>notify</B> <B>after</B> <B>every</B> <B>change</B> <B>x</B> <B>notify</B> <B>always</B><BR>
 <B>...</B><BR>
 <B>#</B> <B>Never</B> <B>notify</B><BR>
 <B>x</B> <B>notify</B> <B>never</B><BR>
 <B>...</B><BR>
 <B>#</B> <B>Force</B> <B>notification</B> <B>now</B><BR>
 <B>x</B> <B>notify</B> <B>now</B><P>
To delete a vector, simply unset its variable or delete its command. When the variable is unset, both the vector and its corresponding Tcl command are destroyed.<P>
<B>#</B> <B>Remove</B> <B>vector</B> <B>x</B><BR>
 <B>unset</B> <B>x</B><P>
If the array variable isn't global (i.e. local to a Tcl procedure), the vector is automatically destroyed when the procedure returns.<P>
<B>proc</B> <B>doit</B> <B>{}</B> <B>{</B><BR>
 <B>#</B> <B>Temporary</B> <B>vector</B> <B>x</B><BR>
 <B>vector</B> <A HREF="http://localhost:6711/man?x?10">x(10)</A><BR>
 <B>set</B> <A HREF="http://localhost:6711/man?x?9">x(9)</A> 2.0<BR>
 <B>...</B><BR>
 <B>}</B><P>
When <B>doit</B> returns, the vector <B>x</B> is automatically removed as the variable is unset. To prevent this, simply make the variable <B>x</B> global before the vector is created, using the <B>global</B> command.<P>
<B>proc</B> <B>doit</B> <B>{}</B> <B>{</B><BR>
 <B>global</B> <B>x</B><BR>
 <B>#</B> <B>Permanent</B> <B>vector</B> <B>x</B><BR>
 <B>vector</B> <A HREF="http://localhost:6711/man?x?10">x(10)</A><BR>
 <B>set</B> <A HREF="http://localhost:6711/man?x?9">x(9)</A> 2.0<BR>
 <B>...</B><BR>
 <B>}</B><P>
<H2><A NAME="sect5" HREF="#toc5"><B>SYNTAX</B></A></H2>
<B>vector</B> <I>vecName</I>?(<I>size</I>)?...<P>
The <B>vector</B> command creates a new vector <I>vecName</I>. Both a Tcl command and array variable <I>vecName</I> are also created. The name <I>vecName</I> must be unique, so another Tcl command or array variable can not already exist in that scope. You can access the components of the vector using its variable. If you change a value in the array, or unset an array element, the vector is updated to reflect the changes. When the variable <I>vecName</I> is unset, the vector and its Tcl command are also destroyed.<P>
A vector can be specified in one of three forms:<P>
<B>vector</B> <I>vecName</I><P>
This creates a new vector <I>vecName</I> which initially has no components.<P>
<B>vector</B> <I>vecName</I>(<I>size</I>)<P>
This second form creates a new vector which will contain <I>size</I> number of components. The components will be indexed starting from zero (0). The default value for the components is <B>0.0</B>.<P>
<B>vector</B> <I>vecName</I>(<I>first</I>:<I>last</I>)<P>
The last form creates a new vector of indexed <I>first</I> through <I>last</I>. <I>First</I> and <I>last</I> can be any integer value so long as <I>first</I> is less than <I>last</I>.<P>
<H2><A NAME="sect6" HREF="#toc6"><B>VECTOR</B> <B>INDICES</B></A></H2>
A vector is indexed by integer numbers. You access the individual vector components via its array variable. The index can be an integer, a numeric expression, a range, or a special key name.<P>
Vectors can be indexed by integers. The index must lie within the range of the vector, otherwise an an error message is returned. Typically the indices of a vector are numbers from zero. But you can use the <B>offset</B> operation to change the indices, on the fly, for a vector.<P>
<B>puts</B> <B>$vecName(0)</B><BR>
 <B>vecName</B> <B>offset</B> <B>-5</B><BR>
 <B>puts</B> <B>$vecName(-5)</B><P>
Vectors can also be indexed by numeric expressions. The result of the expression must be an integer.<P>
<B>set</B> <B>n</B> <B>21</B><BR>
 <B>set</B> <B>vecName($n+3)</B> <B>50.2</B><P>
There are special non-numeric indices; <B>min</B>, <B>max</B>, <B>end</B>, and <B>++end</B>.<P>
<B>puts</B> <B>&quot;min</B> <B>=</B> <B>$vecName($min)"</B><BR>
 <B>set</B> <B>vecName(end)</B> <B>-1.2</B><P>
The indices <B>min</B> and <B>max</B> will return the minimum and maximum values of the vector. The index <B>end</B> returns the value of the last component in the vector. The index <B>++end</B> is for appending new components onto the vector. It automatically extends the vector by one component and sets its value.<P>
<B>#</B> <B>Append</B> <B>an</B> <B>new</B> <B>component</B> <B>to</B> <B>the</B> <B>end</B> <B>set</B> <B>vecName(++end)</B> <B>3.2</B><P>
A range of indices can be indicated by a colon (:).<P>
<B>#</B> <B>Set</B> <B>the</B> <B>first</B> <B>six</B> <B>components</B> <B>to</B> <B>1.0</B> <B>set</B> <B>vecName(0:5)</B> <B>1.0</B><P>
If no index is supplied the first or last component is assumed.<P>
<B>#</B> <B>Print</B> <B>the</B> <B>values</B> <B>of</B> <B>all</B> <B>the</B> <B>components</B> <B>puts</B> <B>$vecName(:)</B><P>
<H2><A NAME="sect7" HREF="#toc7"><B>OPERATIONS</B></A></H2>
You can also use the vector's Tcl command to query or modify it. The general form is<P>
<I>vecName</I> <I>operation</I> ?<I>arg</I>?...<P>
Both <I>operation</I> and its arguments determine the exact behavior of the command. The operations available for vectors are listed below.<P>
<I>vecName</I> <B>append</B> <I>item</I> ?<I>item</I>?...<BR>
 Appends the component values from <I>item</I> to <I>vecName</I>. <I>Item</I> can be either the name of a vector or a list of numeric values.<P>
<I>vecName</I> <B>clear</B><BR>
 Clears the element indices from the array variable associated with <I>vecName</I>. This doesn't affect the components of the vector. By default, the number of entries in the Tcl array doesn't match the number of components in the vector. This is because its too expensive to maintain decimal strings for both the index and value for each component. Instead, the index and value are saved only when you read or write an element with a new index. This command removes the index and value strings from the array. This is useful when the vector is large.<P>
<I>vecName</I> <B>delete</B> <I>index</I> ?<I>index</I>?...<BR>
 Deletes the <I>index</I>th component from the vector <I>vec</I><I>Name</I>. <I>Index</I> is the index of the element to be deleted. This is the same as unsetting the array variable element <I>index</I>. The vector is compacted after all the indices have been deleted.<P>
<I>vecName</I> <B>dup</B> <I>destName</I><BR>
 Copies <I>vecName</I> to <I>destName</I>. <I>DestName</I> is the name of a destination vector. If a vector <I>destName</I> already exists, it is overwritten with the components of <I>vecName</I>. Otherwise a new vector is created.<P>
<I>vecName</I> <B>length</B> ?<I>newSize</I>?<BR>
 Queries or resets the number of components in <I>vec</I><I>Name</I>. <I>NewSize</I> is a number specifying the new size of the vector. If <I>newSize</I> is smaller than the current size of <I>vecName</I>, <I>vecName</I> is truncated. If <I>newSize</I> is greater, the vector is extended and the new components are initialized to <B>0.0</B>. If no <I>new</I><I>Size</I> argument is present, the current length of the vector is returned.<P>
<I>vecName</I> <B>merge</B> <I>srcName</I> ?<I>srcName</I>?...<BR>
 Returns a list of the merged vector components.<P>
The list is formed by merging the components of each vector at each index.<P>
<I>vecName</I> <B>notify</B> <I>keyword</I><BR>
 Controls how vector clients are notified of changes to the vector. The exact behavior is determined by <I>keyword</I>.<P>
<B>always</B> Indicates that clients are to be notified immediately whenever the vector is updated.<P>
<B>never</B> Indicates that no clients are to be notified.<P>
<B>whenidle</B><BR>
 Indicates that clients are to be notified at the next idle point whenever the vector is updated.<P>
<dl>
<dt><B>now</B> <dd>If any client notifications is currently pending, they are notified immediately.<P>
</dd>
</dl>
<B>cancel</B> Cancels pending notifications of clients using the vector.<P>
<B>pending</B><BR>
 Returns <B>1</B> if a client notification is pending, and <B>0</B> otherwise.<P>
<I>vecName</I> <B>offset</B> ?<I>value</I>?<BR>
 Shifts the indices of the vector by the amount specified by <I>value</I>. <I>Value</I> is an integer number. If no <I>value</I> argument is given, the current offset is returned.<P>
<I>vecName</I> <B>populate</B> <I>destName</I> ?<I>density</I>?<BR>
 Creates a vector <I>destName</I> which is a superset of <I>vecName</I>. <I>DestName</I> will include all the components of <I>vecName</I>, in addition the interval between each of the original components will contain a <I>density</I> number of new components, whose values are evenly distributed between the original components values. This is useful for generating abscissas to be interpolated along a spline.<P>
<I>vecName</I> <B>range</B> <I>firstIndex</I> ?<I>lastIndex</I>?...<BR>
 Returns a list of numeric values representing the vector components between two indices. Both <I>firstIndex</I> and <I>lastIndex</I> are indices representing the range of components to be returned. If <I>lastIn</I><I>dex</I> is less than <I>firstIndex</I>, the components are listed in reverse order.<P>
<I>vecName</I> <B>search</B> <I>value</I> ?<I>value</I>?<BR>
 Searches for a value or range of values among the components of <I>vecName</I>. If one <I>value</I> argument is given, a list of indices of the components which equal <I>value</I> is returned. If a second <I>value</I> is also provided, then the indices of all components which lie within the range of the two values are returned. If no components are found, then <B>&quot;&quot;</B> is returned.<P>
<I>vecName</I> <B>set</B> <I>item</I><BR>
 Resets the components of the vector to <I>item</I>. <I>Item</I> can be either a list of numeric expressions or another vector.<P>
<I>vecName</I> <B>sort</B> ?<B>-reverse</B>? ?<I>argName</I>?...<BR>
 Sorts the vector <I>vecName</I> in increasing order. If the <B>-reverse</B> flag is present, the vector is sorted in decreasing order. If other arguments <I>argName</I> are present, they are the names of vectors which will be rearranged in the same manner as <I>vecName</I>. Each vector must be the same length as <I>vecName</I>. You could use this to sort the x vector of a graph, while still retaining the same x,y coordinate pairs in a y vector.<P>
<I>vecName</I> <B>*</B> <I>item</I><BR>
 Returns a list representing the product of <I>vecName</I> and <I>item</I>. If <I>item</I> is the name of a vector, vector multiplication is performed. The vectors must be the same length. Otherwise, <I>item</I> must be a scalar value and each component of <I>vecName</I> is multiplied by that value. The component values of <I>vecName</I> do not change.<P>
<I>vecName</I> <B>+</B> <I>item</I><BR>
 Returns a list representing the sum of <I>vecName</I> and <I>item</I>. If <I>item</I> is the name of a vector, vector addition is performed. The vectors must be the same length. Otherwise, <I>item</I> must be a scalar value and each component of <I>vecName</I> is added by that value. The component values of <I>vecName</I> do not change.<P>
<I>vecName</I> <B>-</B> <I>item</I><BR>
 Returns a list representing the subtraction of <I>item</I> from <I>vecName</I>. If <I>item</I> is the name of a vector, vector subtraction is performed. The vectors must be the same length. Otherwise, <I>item</I> must be a scalar value and the list will contain each component of <I>vecName</I> is subtracted by that value. The component values of <I>vecName</I> do not change.<P>
<I>vecName</I> <B>/</B> <I>item</I><BR>
 Returns a list representing the product of <I>vecName</I> and <I>item</I>. If <I>item</I> is the name of a vector, vector division is performed. The vectors must be the same length. Otherwise, <I>item</I> must be a scalar value and each component of <I>vecName</I> is divided by that value. The component values of <I>vecName</I> do not change.<P>
<H2><A NAME="sect8" HREF="#toc8"><B>C</B> <B>LANGUAGE</B> <B>API</B></A></H2>
You can create, modify, and destroy vectors from C code, using library routines. You need to include the header file <B>blt.h</B>. It contains the definition of the structure <B>Blt_Vector</B>, which represents the vector. It appears below.<P>
typedef struct {<BR>
 double *<I>valueArr</I>;<BR>
 int <I>numValues</I>;<BR>
 int <I>arraySize</I>;<BR>
 double <I>min</I>, <I>max</I>;<BR>
 } <B>Blt_Vector</B>;<P>
The field <I>valueArr</I> points to memory holding the vector components. The components are stored in a double precision array, whose size size is represented by <I>arraySize</I>. <I>NumValues</I> is the length of vector. The size of the array is always equal to or larger than the length of the vector. <I>Min</I> and <I>max</I> are minimum and maximum component values.<P>
<H2><A NAME="sect9" HREF="#toc9"><B>LIBRARY</B> <B>ROUTINES</B></A></H2>
The following routines are available from C to manage vectors. Vectors are identified by the vector name.<P>
<B>Blt_CreateVector</B><P>
Synopsis:<BR>
 int <B>Blt_CreateVector</B> (<I>interp</I>, <I>vecName</I>, <I>length</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<BR>
 int <I>length</I>;<P>
Description:<BR>
 Creates a new vector <I>vecName</I> with a length of <I>length</I>. <B>Blt_CreateVector</B> creates both a new Tcl command and array variable <I>vecName</I>. Neither a command nor variable named <I>vecName</I> can already exist.<P>
Results: Returns <B>TCL_OK</B> if the vector is successfully created. If <I>length</I> is negative, a Tcl variable or command <I>vecName</I> already exists, or memory cannot be allocated for the vector, then <B>TCL_ERROR</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_DeleteVector</B><P>
Synopsis:<BR>
 int <B>Blt_DeleteVector</B> (<I>interp</I>, <I>vecName</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<P>
Description:<BR>
 Removes the vector <I>vecName</I>. <I>VecName</I> is the name of a vector which must already exist. Both the Tcl command and array variable <I>vec</I><I>Name</I> are destroyed. All clients of the vector will be notified immediately that the vector has been destroyed.<P>
Results: Returns <B>TCL_OK</B> if the vector is successfully deleted. If <I>vecName</I> is not the name a vector, then <B>TCL_ERROR</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_GetVector</B><P>
Synopsis:<BR>
 int <B>Blt_GetVector</B> (<I>interp</I>, <I>vecName</I>, <I>vecPtr</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<BR>
 Blt_Vector *<I>vecPtr</I>;<P>
Description:<BR>
 Retrieves the vector <I>vecName</I>. The fields of the structure <I>vecPtr</I> are filled with the current values from the vector. <I>VecName</I> is the name of a vector which must already exist.<P>
Results: Returns <B>TCL_OK</B> if the vector is successfully retrieved. If <I>vecName</I> is not the name of a vector, then <B>TCL_ERROR</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_ResetVector</B><P>
Synopsis:<BR>
 int <B>Blt_ResetVector</B> (<I>interp</I>, <I>vecName</I>, <I>vecPtr</I>, <I>freeProc</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<BR>
 Blt_Vector *<I>vecPtr</I>;<BR>
 Tcl_FreeProc *<I>freeProc</I>;<P>
Description:<BR>
 Resets the components of the vector <I>vecName</I>. The fields of the <I>vecPtr</I> contain the updated values. Calling <B>Blt_ResetVector</B> will trigger the vector to dispatch notifications. <I>Vec</I><I>Name</I> is the name of a vector which must already exist. <I>FreeProc</I> indicates how the storage for the vector component array (<I>val</I><I>ueArr</I>) was allocated. It is used to determine how to reallocate memory when the vector is resized or destroyed. It must be <B>TCL_DYNAMIC</B>, <B>TCL_STATIC</B>, <B>TCL_VOLATILE</B>, or a pointer to a function to free the memory allocated for the vector array. If <I>freeProc</I> is <B>TCL_VOLATILE</B>, it indicates that <I>valueArr</I> must be copied and saved. If <I>freeProc</I> is <B>TCL_DYNAMIC</B>, it indicates that <I>valueArr</I> was dynamically allocated and that Tcl should free <I>valueArr</I> if necessary. <B>Static</B> indicates that nothing should be done to release storage for <I>valueArr</I>.<P>
Results: Returns <B>TCL_OK</B> if the vector is successfully resized. If <I>newSize</I> is negative, a vector <I>vecName</I> does not exist, or memory cannot be allocated for the vector, then <B>TCL_ERROR</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_ResizeVector</B><P>
Synopsis:<BR>
 int <B>Blt_ResizeVector</B> (<I>interp</I>, <I>vecName</I>, <I>newSize</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<BR>
 int <I>newSize</I>;<P>
Description:<BR>
 Resets the length of the vector <I>vecName</I> to <I>newSize</I>. If <I>newSize</I> is smaller than the current size of <I>vecName</I>, <I>vecName</I> is truncated. If <I>newSize</I> is greater, the vector is extended and the new components are initialized to <B>0.0</B>. <I>VecName</I> is the name of a vector which must already exist. Calling <B>Blt_ResetVector</B> will trigger the vector to dispatch notifications.<P>
Results: Returns <B>TCL_OK</B> if the vector is successfully resized. If <I>newSize</I> is negative, a vector <I>vecName</I> does not exist, or memory can not be allocated for the vector. then <B>TCL_ERROR</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_VectorExists</B><P>
Synopsis:<BR>
 int <B>Blt_VectorExists</B> (<I>interp</I>, <I>vecName</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<P>
Description:<BR>
 Indicates if a vector named <I>vecName</I> exists in <I>interp</I>.<P>
Results: Returns <B>1</B> if a vector <I>vecName</I> exists and <B>0</B> otherwise.<P>
If your application needs to be notified when a vector changes, it can allocate a unique <I>client</I> <I>identifier</I> for itself. Using this identifier, you can then register a call-back to be made whenever the vector is updated or destroyed. By default, the call-backs are made at the next idle point. This can be changed to occur at the time the vector is modified. An application can allocate more than one identifier for any vector. When the client application is done with the vector, it should free the identifier.<P>
The call-back routine must of the following type.<P>
typedef void (<B>Blt_VectorChangedProc</B>) (Tcl_Interp *<I>interp</I>, ClientData <I>clientData</I>, Blt_VectorNotify <I>notify</I>);<P>
<I>ClientData</I> is passed to this routine whenever it is called. You can use this to pass information to the call-back. The <I>notify</I> argument indicates whether the vector has been updated of destroyed. It is an enumerated type.<P>
typedef enum {<BR>
 <B>BLT_VECTOR_NOTIFY_UPDATE</B>=1,<BR>
 <B>BLT_VECTOR_NOTIFY_DESTROY</B>=2<BR>
 } <B>Blt_VectorNotify</B>;<P>
<B>Blt_AllocVectorId</B><P>
Synopsis:<BR>
 Blt_VectorId <B>Blt_AllocVectorId</B> (<I>interp</I>, <I>vecName</I>) Tcl_Interp *<I>interp</I>;<BR>
 char *<I>vecName</I>;<P>
Description:<BR>
 Allocates an client identifier for with the vector <I>vecName</I>. This identifier can be used to specify a call-back which is triggered when the vector is updated or destroyed.<P>
Results: Returns a client identifier if successful. If <I>vecName</I> is not the name of a vector, then <B>NULL</B> is returned and <I>interp-&gt;result</I> will contain an error message.<P>
<B>Blt_SetVectorChangedProc</B><P>
Synopsis:<BR>
 void <B>Blt_SetVectorChangedProc</B> (<I>clientId</I>, <I>proc</I>, <I>clientData</I>); Blt_VectorId <I>clientId</I>;<BR>
 Blt_VectorChangedProc *<I>proc</I>; ClientData *<I>clientData</I>;<P>
Description:<BR>
 Specifies a call-back routine to be called whenever the vector associated with <I>clien</I><I>tId</I> is updated or deleted. <I>Proc</I> is a pointer to call-back routine and must be of the type <B>Blt_VectorChangedProc</B>. <I>ClientData</I> is a one-word value to be passed to the routine when it is invoked. If <I>proc</I> is <B>NULL</B>, then the client is not notified.<P>
Results: The designated call-back procedure will be invoked when the vector is updated or destroyed.<P>
<B>Blt_FreeVectorId</B><P>
Synopsis:<BR>
 void <B>Blt_FreeVectorId</B> (<I>clientId</I>); Blt_VectorId <I>clientId</I>;<P>
Description:<BR>
 Frees the client identifier. Memory allocated for the identifier is released. The client will no longer be notified when the vector is modified.<P>
Results: The designated call-back procedure will be no longer be invoked when the vector is updated or destroyed.<P>
<B>Blt_NameOfVectorId</B><P>
Synopsis:<BR>
 char *<B>Blt_NameOfVectorId</B> (<I>clientId</I>); Blt_VectorId <I>clientId</I>;<P>
Description:<BR>
 Retrieves the name of the vector associated with the client identifier <I>clientId</I>.<P>
Results: Returns the name of the vector associated with <I>clientId</I>. If <I>clientId</I> is not an identifier or the vector has been destroyed, <B>NULL</B> is returned.<P>
<H2><A NAME="sect10" HREF="#toc10"><B>C</B> <B>API</B> <B>EXAMPLE</B></A></H2>
<B>#include</B> <B>&lt;tcl.h&gt;</B><BR>
 <B>#include</B> <B>&lt;blt.h&gt;</B><P>
<B>Blt_Vector</B> <B>vecInfo;</B><P>
<B>/*</B> <B>Create</B> <B>new</B> <B>vector</B> <B>&quot;x&quot;</B> <B>of</B> <B>50</B> <B>elements</B> <B>*/</B> <B>if</B> <B>(Blt_CreateVector(interp,</B> <B>&quot;x",</B> <B>50)</B> <B>!=</B> <B>TCL_OK)</B> <B>{</B> <B>return</B> <B>TCL_ERROR;</B><BR>
 <B>}</B><P>
<B>/*</B> <B>Get</B> <B>the</B> <B>vector</B> <B>*/</B><BR>
 <B>if</B> <B>(Blt_GetVector(interp,</B> <B>&quot;x",</B> <B>&amp;vecInfo)</B> <B>!=</B> <B>TCL_OK)</B> <B>{</B> <B>return</B> <B>TCL_ERROR;</B><BR>
 <B>}</B><BR>
 <B>/*</B> <B>Print</B> <B>the</B> <B>min</B> <B>and</B> <B>max</B> <B>component</B> <B>values</B> <B>*/</B> <B>printf("min=%g</B> <B>max=%g\n",</B> <B>vecInfo.min,</B> <B>vecInfo.max);</B><P>
<B>/*</B> <B>Allocate</B> <B>new</B> <B>storage</B> <B>for</B> <B>the</B> <B>vector</B> <B>*/</B> <B>newArr</B> <B>=</B> <B>(double</B> <B>*)malloc(sizeof(double)</B> <B>*</B> <B>10000);</B> <B>...</B><BR>
 <B>vecInfo.numValues</B> <B>=</B> <B>10000;</B><BR>
 <B>vecInfo.valueArr</B> <B>=</B> <B>newArr;</B><P>
<B>/*</B> <B>Reset</B> <B>the</B> <B>vector.</B> <B>Clients</B> <B>get</B> <B>notified</B> <B>*/</B> <B>if</B> <B>(Blt_ResetVector(interp,</B> <B>&quot;x",</B> <B>&amp;vecInfo,</B> <B>TCL_DYNAMIC)</B> <B>!=</B> <B>TCL_OK)</B> <B>{</B> <B>return</B> <B>TCL_ERROR;</B><BR>
 <B>}</B><P>
<H2><A NAME="sect11" HREF="#toc11"><B>KEYWORDS</B></A></H2>
vector, graph, widget<P>
<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">INTRODUCTION</A></LI>
<LI><A NAME="toc4" HREF="#sect4">EXAMPLE</A></LI>
<LI><A NAME="toc5" HREF="#sect5">SYNTAX</A></LI>
<LI><A NAME="toc6" HREF="#sect6">VECTOR INDICES</A></LI>
<LI><A NAME="toc7" HREF="#sect7">OPERATIONS</A></LI>
<LI><A NAME="toc8" HREF="#sect8">C LANGUAGE API</A></LI>
<LI><A NAME="toc9" HREF="#sect9">LIBRARY ROUTINES</A></LI>
<LI><A NAME="toc10" HREF="#sect10">C API EXAMPLE</A></LI>
<LI><A NAME="toc11" HREF="#sect11">KEYWORDS</A></LI>
</UL>
</BODY></HTML>
